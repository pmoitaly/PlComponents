# TPlLanguageJsonEngine

## Overview

`TPlLanguageJsonEngine` is a JSON-based persistence engine for the **PlComponents localization system**. It implements the `IPlLanguageEngine` contract through inheritance from `TPlLanguageEngine` and provides **RTTI-driven serialization and deserialization** of translatable properties to and from JSON files.

The engine is designed to be:

- **Symmetric** (save and load follow the same structural rules)
- **Recursive** (nested objects are supported)
- **Defensive** (data is preserved even if not immediately applicable)
- **Extensible** (intended as a reference implementation for custom engines)

It is suitable for both **design-time language extraction** and **runtime language loading**.

---

## Design Goals

The engine intentionally focuses on the following goals:

1. Provide a **clear JSON representation** of all translatable UI strings
2. Preserve **future translation potential**, even when some strings are currently ignored at runtime
3. Ensure **behavioral symmetry** between serialization and deserialization
4. Reuse and respect all filtering and policy decisions defined in `TPlLanguageEngine`
5. Serve as a **canonical example** for writing custom persistence engines

---

## JSON Structure

A typical JSON language file generated by this engine looks like this:

```json
{
  "MainForm": {
    "Caption": "Main window",
    "ButtonOK": {
      "Caption": "OK",
      "Hint": "Confirm operation"
    }
  },
  "Strings": {
    "FILE_NOT_FOUND": "File not found",
    "INVALID_USER": "Invalid user"
  }
}
```

### Structure rules

- **Top-level object**
  - Keys correspond to component names
  - Values are JSON objects containing translated properties

- **Component nodes**
  - Only include properties that are considered translatable
  - Nested objects are represented as nested JSON objects

- **`Strings` section** (optional)
  - Used to populate the runtime translation dictionary
  - Keys are normalized string identifiers
  - Values are translated strings

---

## Class Responsibilities

### TPlLanguageJsonEngine

The class is responsible for:

- Traversing component trees
- Serializing translatable properties to JSON
- Applying translations from JSON to live components
- Loading runtime string translations into `FTranslationsDict`

It does **not**:

- Decide which properties are translatable (delegated to `TPlLanguageEngine`)
- Enforce language policies
- Handle application-level errors

---

## Public API

### Constructor

```pascal
constructor Create; override;
```

Initializes the engine and sets:

- `FFileStyle := lpJson`

---

### LoadTranslation

```pascal
procedure LoadTranslation(ASource: TComponent; const AFile: string); override;
```

Loads a JSON language file and applies translations to the component tree rooted at `ASource`.

Behavior:

1. Reads and parses the JSON file
2. Loads the optional `Strings` section into the runtime dictionary
3. Applies translations recursively to components and nested objects

Notes:

- Missing properties are silently ignored
- No exceptions are raised for missing keys

---

### SaveTranslation

```pascal
procedure SaveTranslation(ASource: TComponent; const AFile: string); override;
```

Serializes all eligible components and their translatable properties into a JSON file.

Behavior:

- Traverses the entire component tree recursively
- Applies eligibility and exclusion rules
- Writes the file only if at least one translation is found

Defensive design:

- Properties such as `Caption` and `Hint` are **always saved**, even if they may be ignored at runtime due to `ExcludeOnAction`
- This ensures that translations are not lost if policies change later

---

## Core Internal Methods

### ComponentToJson

```pascal
procedure ComponentToJson(ASource: TComponent; AStructure: TJSONObject);
```

**Purpose**

- Entry point for component serialization
- Manages traversal of the component tree

Responsibilities:

- Checks `IsEligibleClass`
- Creates a JSON node for the component
- Delegates property serialization to `SerializeObject`
- Recursively processes subcomponents

This method deals exclusively with **component-level concerns**.

---

### SerializeObject

```pascal
procedure SerializeObject(ASource: TObject; AJson: TJSONObject);
```

**Purpose**

- Serializes an arbitrary object using RTTI
- Handles both components and nested objects uniformly

Behavior:

- Iterates through RTTI properties
- Serializes:
  - String properties
  - `TStrings` (stored as concatenated text)
  - Nested objects (recursively)

Exclusions:

- `TFont` properties are explicitly ignored
- Properties failing `IsTranslatableProperty` are skipped

This method contains **all object-level serialization logic**.

---

### TranslateObject

```pascal
procedure TranslateObject(AJson: TJSONObject; ATarget: TObject);
```

**Purpose**

- Applies JSON translations to a live object instance
- Logical inverse of `SerializeObject`

Behavior:

- Matches JSON keys to RTTI properties
- Restores multiline strings
- Applies translations only if `ShouldTranslateProperty` returns `True`
- Recursively processes nested objects

This symmetry guarantees predictable save/load behavior.

---

### LoadTranslationsToDict

```pascal
procedure LoadTranslationsToDict(ASource: TJSONObject);
```

Loads the optional `Strings` JSON section into the runtime translation dictionary.

Notes:

- Called **before** applying component translations
- Missing or malformed sections are ignored safely

---

## Filtering and Policy Rules

All filtering logic is inherited from `TPlLanguageEngine`:

- `IsEligibleClass`
- `IsTranslatableProperty`
- `ShouldTranslateProperty`
- `ExcludeClasses`
- `ExcludeProperties`
- `ExcludeOnAction`

The JSON engine **never overrides** these rules; it only applies them consistently.

---

## Intentional Design Choices

### Saving more than translating

Some properties (e.g. `Caption`, `Hint` on components with an `Action`) may be:

- Saved to JSON
- Ignored at runtime during translation

This is intentional and defensive:

- Policies may change
- Translations should not be lost

---

### No strict schema enforcement

- JSON structure is flexible
- Unknown nodes are ignored
- Missing nodes do not cause errors

This allows gradual evolution of language files.

---

## When to Use This Engine

Use `TPlLanguageJsonEngine` when:

- You want a **human-readable** language format
- You need **nested object support**
- You want a reference implementation for custom engines

---

## When Not to Use It

Avoid this engine if:

- You require extremely compact files
- You need strict schema validation
- You want binary or encrypted persistence

---

## Summary

`TPlLanguageJsonEngine` is a **clean, symmetric, and extensible** JSON persistence engine.

It:

- Fully respects `TPlLanguageEngine` policies
- Preserves translation data defensively
- Provides a solid foundation for future extensions

It should be considered the **canonical example** for implementing custom language engines in PlComponents.

---

## License

Released under the **MIT License**.


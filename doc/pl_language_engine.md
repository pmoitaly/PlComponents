# TPlLanguageEngine

## Overview

`TPlLanguageEngine` is the abstract base class for all persistence engines used by `TPlLanguage` in the *PlLanguage* framework. It provides the common infrastructure required to **load**, **save**, and **apply translations** to Delphi components using RTTI-based inspection.

Concrete persistence engines (INI, JSON, XML, etc.) must inherit from this class and implement the persistence-specific logic by overriding abstract methods.

A key design principle of `TPlLanguageEngine` is the **strict separation between**:

* **Structural eligibility** of a property (`IsTranslatableProperty`)
* **Contextual translation decision** (`ShouldTranslateProperty`)

This separation allows safe extensibility and fine-grained control over translation behavior.

It encapsulates the common logic required to:

- Inspect components via RTTI
- Decide *what* can be translated
- Decide *when* a property should be translated
- Delegate actual persistence to concrete implementations (INI, JSON, …)

The class is designed for **inheritance**, not for direct use.

---

## Responsibilities

`TPlLanguageEngine` is responsible for:

* Discovering translatable components and properties via RTTI
* Applying exclusion rules at class and property level
* Managing runtime translation dictionaries
* Delegating persistence to concrete subclasses
* Handling automatic creation of missing language files

## Design Principles

1. **Separation of concerns**
   - The engine decides *which* properties are eligible
   - Concrete engines decide *how* data is persisted

2. **Two-level filtering**
   - Structural eligibility (`IsTranslatableProperty`)
   - Contextual decision (`ShouldTranslateProperty`)

3. **Non-intrusive behavior**
   - No UI refresh
   - No exception policy
   - No global state

4. **Fail-safe loading**
   - Missing files can be created if explicitly allowed
   - Otherwise, operations are silently skipped

---

## Class Hierarchy

```text
TInterfacedObject
  └── TPlLanguageEngine
```

Implements:

* `IPlLanguageEngine`

---

## Protected Fields

### `FContext: TRTTIContext`

Shared RTTI context used during the engine lifetime for type and property inspection.

---

### `FFileStyle: TPlLanguagePersistence`

Indicates the persistence format handled by the concrete engine (e.g. INI, JSON).

---

### `FLanguageInfoLoader: IPlLanguageInfoLoader`

Loader responsible for reading persisted language metadata.

---

### `FTranslationsDict: TDictionary<string, string>`

Internal dictionary used for runtime string translation. Keys are normalized strings, values are encoded translations.

---

## Protected Methods

### `function CreateInfoLoader: IPlLanguageInfoLoader; virtual; abstract;`

Creates and returns an instance of the language metadata loader.

**Must be implemented by subclasses.**

---

### `function HasAction(ASource: TObject): Boolean;`

Returns `True` if the specified object exposes an `Action` property and it is assigned.

Used to determine whether translation should be suppressed when `ExcludeOnAction` is enabled.

---

### `function IsEligibleClass(AnElement: TPersistent): Boolean;`

Determines whether a component instance is eligible for translation.

Eligibility rules:

* Must be a `TComponent`
* Must have a non-empty `Name`
* Must not be listed in internal or user-defined excluded classes

---

### `function IsTranslatableProperty(AProperty: TRttiProperty): Boolean;`

Checks whether a property is *structurally* eligible for translation.

A property is considered translatable if:

* It is published
* It is readable and writable
* Its type is string-compatible
* It is not part of the internal untranslatable property list

This method does **not** consider runtime context or exclusion rules.

---

### `function ShouldTranslateProperty(AProperty: TRttiProperty; ASource: TObject): Boolean;`

Determines whether a property should actually be translated in the current context.

This method is evaluated **after** `IsTranslatableProperty` and applies higher-level rules:

* User-defined excluded properties
* Action-related suppression (`ExcludeOnAction`)
* Reserved property names (e.g. `Name`)
* Caption/Hint/Text precedence when Actions are present

---

### `function LanguageFileExists(ASource: TComponent; const AFile: string): Boolean;`

Checks whether the language file exists.

If `CreateIfMissing` is `True`:

* Missing directories are created
* Missing files are generated by calling `SaveLanguage`

Returns `True` if the file exists or was successfully created.

---

### `procedure LoadTranslation(ASource: TComponent; const AFile: string; AStore: IPlTranslationStore = nil); virtual; abstract;`

Loads translations from a persistence-specific file.

**Must be implemented by subclasses.**

Expected responsibilities:

* Apply translated values to component properties
* Populate the runtime translation dictionary

### Lifecycle of LoadLanguage

1. Verify language file existence
2. Optionally create directories/files (`CreateIfMissing`)
3. Call `LoadTranslation` (implemented by concrete engine)
4. Apply translated values via RTTI

The base class does **not** parse files directly.

---

### `procedure SaveTranslation(ASource: TComponent; const AFile: string); virtual; abstract;`

Saves translations to a persistence-specific file.

**Must be implemented by subclasses.**

Expected responsibilities:

* Inspect components via RTTI
* Extract translatable properties
* Persist translation data

### Lifecycle of SaveLanguage

1. Ensure target directory exists (optional)
2. Inspect components and properties
3. Extract translatable values
4. Call `SaveTranslation` (implemented by concrete engine)

Purpose:

> Generate a language file for the *current language*, even if translations are incomplete.

---

### `procedure SetPropertyValue(AComponent: TComponent; const AProp, AValue: string);`

Assigns a translated value to a component property using RTTI.

Before assignment:

* Translation eligibility is verified
* Multiline encoding is restored

---

## Public Methods

### `constructor Create; virtual;`

Creates the language engine and initializes:

* Default exclusion lists
* Internal RTTI context
* Translation dictionary
* Language metadata loader

---

### `destructor Destroy; override;`

Releases all internal resources, including:

* RTTI context
* Translation dictionary
* Exclusion lists

---

### `procedure LoadLanguage(ASource: TComponent; const AFile: string; AStore: IPlTranslationStore = nil); virtual;`

Loads language data into the specified component container.

Behavior:

* Verifies file existence
* Optionally creates missing files
* Delegates loading to `LoadTranslation`

---

### `function ReadLanguageInfo(const AFile: string): TPlLanguageInfo;`

Reads language metadata from the specified file using the configured loader.

---

### `procedure SaveLanguage(ASource: TComponent; const AFile: string); virtual;`

Saves language data from the specified component container.

Behavior:

* Ensures target directories exist (if enabled)
* Delegates persistence to `SaveTranslation`

---

### `function Translate(const AString: string): string;`

Translates a runtime string using the internal translation dictionary.

Characteristics:

* Keys are normalized before lookup
* Multiline encoding is restored
* If no translation is found, the original string is returned
* Never raises exceptions

---

## Public Properties

### `CreateIfMissing: Boolean`

When `True`, missing language files and directories are created automatically during load and save operations.

---

### `ExcludeClasses: TStrings`

List of component class names explicitly excluded from translation.

---

### `ExcludeOnAction: Boolean`

When `True`, properties managed by Actions (`Caption`, `Hint`, `Text`) are not translated.

---

### `ExcludeProperties: TStrings`

List of property names that must never be translated.

---

### `LanguageInfo: TPlLanguageInfo`

Holds the language metadata used by the application (e.g. language name, code, author).

---

## Extending TPlLanguageEngine

To implement a concrete persistence engine:

1. Inherit from `TPlLanguageEngine`
2. Implement:

   * `CreateInfoLoader`
   * `LoadTranslation`
   * `SaveTranslation`
3. Populate `FTranslationsDict` consistently with `TPlLineEncoder`

This design ensures a consistent translation pipeline across all persistence formats.

---

## Design Notes

* RTTI inspection is centralized and reused
* Translation rules are layered and predictable
* Runtime translation is decoupled from persistence
* Safe defaults prevent accidental translation of sensitive properties

---
---

## Intentional Limitations

These are **by design**:

- No UI repainting
- No centralized error handling
- No multi-language concurrency
- No dependency on `TPlLanguageServer`

The engine is reusable **with or without** the server.

---

## Common Pitfalls

### Assuming all string properties are translated

Only properties that pass **both** filtering stages are processed.

---

### Translating Action-bound captions manually

When `ExcludeOnAction` is enabled, captions and hints are skipped intentionally.

---

### Creating engines that bypass base logic

Doing so breaks consistency and future compatibility.

Always delegate common behavior to the base class.

---

## Summary

`TPlLanguageEngine` is the **contractual heart** of the localization system.

It ensures:

- Predictable behavior
- Consistent filtering
- Safe extensibility

Concrete engines remain focused, simple, and replaceable.

---

## License

Released under the **MIT License**.
